<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>會場座位設計系統</title>
    
    <!-- React 和相關依賴 -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 自定義樣式 -->
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background-color: #f9fafb;
        }
        #root { 
            width: 100%; 
            min-height: 100vh; 
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-size: 18px;
            color: #666;
        }
        /* 確保 canvas 不會模糊 */
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading">
            <div>
                <div style="text-align: center;">
                    <div style="display: inline-block; width: 40px; height: 40px; border: 3px solid #e5e7eb; border-top: 3px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 16px;"></div>
                    <div>正在載入會場座位設計系統...</div>
                </div>
            </div>
        </div>
    </div>

    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Lucide React 圖標組件
        const Users = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z" 
        }));

        const Plus = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M12 4v16m8-8H4" 
        }));

        const Shuffle = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z" 
        }));

        const Save = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" 
        }));

        const RotateCcw = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" 
        }));

        const Edit3 = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, [
            React.createElement('path', { 
                key: "1",
                strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
                d: "M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7" 
            }),
            React.createElement('path', { 
                key: "2",
                strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
                d: "m18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" 
            })
        ]);

        const Move = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M13 17h8m0 0V9m0 8l-8-8-4 4-6-6" 
        }));

        const Hand = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 113 0v1m0 0V11m0-5.5a1.5 1.5 0 113 0v3m0 0V11" 
        }));

        const Download = () => React.createElement('svg', { 
            className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, React.createElement('path', { 
            strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, 
            d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" 
        }));

        const SeatingDesigner = () => {
          const canvasRef = useRef(null);
          const [mode, setMode] = useState('design');
          const [designMode, setDesignMode] = useState('create');
          const [currentTool, setCurrentTool] = useState('seat');
          const [isDragging, setIsDragging] = useState(false);
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
          const [selectedBlock, setSelectedBlock] = useState(null);
          const [draggedBlock, setDraggedBlock] = useState(null);
          const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
          const [previewBlock, setPreviewBlock] = useState(null);
          const [viewOffset, setViewOffset] = useState({ x: 0, y: 0 });
          const [isCanvasDragging, setIsCanvasDragging] = useState(false);
          const [canvasDragStart, setCanvasDragStart] = useState({ x: 0, y: 0 });
          
          const [blocks, setBlocks] = useState([
            {
              id: 'stage',
              type: 'stage',
              x: 300,
              y: 50,
              width: 200,
              height: 60,
              color: '#374151',
              label: '舞台/講台'
            }
          ]);
          
          const [groups, setGroups] = useState([
            { id: 1, name: '企業A團隊', size: 12, color: '#FF6B6B' },
            { id: 2, name: '學校B師生', size: 15, color: '#4ECDC4' },
            { id: 3, name: '協會C會員', size: 8, color: '#45B7D1' },
            { id: 4, name: '個人報名', size: 20, color: '#96CEB4' }
          ]);
          
          const [newGroup, setNewGroup] = useState({ name: '', size: 0 });
          const [showGroupModal, setShowGroupModal] = useState(false);
          
          const toolStyles = {
            seat: { color: '#10B981', label: '座位區' },
            aisle: { color: '#E5E7EB', label: '走道' },
            vip: { color: '#8B5CF6', label: '貴賓席' },
            stage: { color: '#374151', label: '舞台' }
          };
          
          const cellSize = 25;
          const canvasWidth = 800;
          const canvasHeight = 600;
          
          // 重新分配所有座位編號
          const reassignSeatNumbers = (blockList) => {
            if (!blockList || blockList.length === 0) return blockList;
            
            const seatBlocks = blockList
              .filter(block => block.type === 'seat')
              .sort((a, b) => a.y - b.y);
            
            let currentNumber = 1;
            
            const updatedBlocks = blockList.map(block => {
              if (block.type === 'seat' && block.seats) {
                const updatedSeats = block.seats.map(seat => {
                  if (!seat.removed) {
                    return {
                      ...seat,
                      number: currentNumber++
                    };
                  }
                  return seat;
                });
                
                return { ...block, seats: updatedSeats };
              }
              return block;
            });
            
            return updatedBlocks;
          };
          
          // 生成座位數據
          const generateSeats = (rows, seatsPerRow) => {
            const seats = [];
            
            for (let row = 0; row < rows; row++) {
              for (let seat = 0; seat < seatsPerRow; seat++) {
                seats.push({
                  id: `${row}-${seat}`,
                  number: row * seatsPerRow + seat + 1,
                  row,
                  seat,
                  group: null,
                  removed: false
                });
              }
            }
            return seats;
          };
          
          // 畫布繪製
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = '#F9FAFB';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // 繪製網格
            ctx.strokeStyle = '#E5E7EB';
            ctx.lineWidth = 0.5;
            
            const gridStartX = (viewOffset.x % cellSize) - cellSize;
            const gridStartY = (viewOffset.y % cellSize) - cellSize;
            
            for (let x = gridStartX; x <= canvasWidth; x += cellSize) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, canvasHeight);
              ctx.stroke();
            }
            for (let y = gridStartY; y <= canvasHeight; y += cellSize) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(canvasWidth, y);
              ctx.stroke();
            }
            
            // 繪製區塊
            blocks.forEach(block => {
              const blockX = block.x + viewOffset.x;
              const blockY = block.y + viewOffset.y;
              
              if (blockX + block.width >= 0 && blockX <= canvasWidth && 
                  blockY + block.height >= 0 && blockY <= canvasHeight) {
                
                ctx.fillStyle = block.color;
                ctx.fillRect(blockX, blockY, block.width, block.height);
                
                ctx.strokeStyle = selectedBlock?.id === block.id ? '#3B82F6' : '#6B7280';
                ctx.lineWidth = selectedBlock?.id === block.id ? 3 : 1;
                ctx.strokeRect(blockX, blockY, block.width, block.height);
                
                if (block.type !== 'seat') {
                  ctx.fillStyle = block.type === 'aisle' ? '#374151' : '#FFFFFF';
                  ctx.font = '12px Arial';
                  ctx.textAlign = 'center';
                  ctx.fillText(
                    block.label || toolStyles[block.type].label,
                    blockX + block.width / 2,
                    blockY + block.height / 2 + 4
                  );
                }
                
                if (block.type === 'seat' && block.seats) {
                  const seatWidth = block.width / block.seatsPerRow;
                  const seatHeight = block.height / block.rows;
                  
                  ctx.font = '10px Arial';
                  
                  block.seats.forEach((seat, index) => {
                    if (seat.removed) return;
                    
                    const row = Math.floor(index / block.seatsPerRow);
                    const col = index % block.seatsPerRow;
                    const seatX = blockX + col * seatWidth;
                    const seatY = blockY + row * seatHeight;
                    
                    ctx.fillStyle = seat.group ? seat.group.color : '#F3F4F6';
                    ctx.fillRect(seatX + 2, seatY + 2, seatWidth - 4, seatHeight - 4);
                    
                    ctx.strokeStyle = designMode === 'edit' && selectedBlock?.id === block.id ? '#EF4444' : '#D1D5DB';
                    ctx.lineWidth = designMode === 'edit' && selectedBlock?.id === block.id ? 2 : 0.5;
                    ctx.strokeRect(seatX + 2, seatY + 2, seatWidth - 4, seatHeight - 4);
                    
                    ctx.fillStyle = seat.group ? '#FFFFFF' : '#6B7280';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                      seat.number.toString(),
                      seatX + seatWidth / 2,
                      seatY + seatHeight / 2 + 3
                    );
                  });
                }
              }
            });
            
            // 繪製預覽區塊
            if (previewBlock && mode === 'design' && designMode === 'create') {
              const previewX = previewBlock.x + viewOffset.x;
              const previewY = previewBlock.y + viewOffset.y;
              
              ctx.globalAlpha = 0.6;
              ctx.fillStyle = previewBlock.color;
              ctx.fillRect(previewX, previewY, previewBlock.width, previewBlock.height);
              
              ctx.strokeStyle = '#3B82F6';
              ctx.lineWidth = 2;
              ctx.setLineDash([5, 5]);
              ctx.strokeRect(previewX, previewY, previewBlock.width, previewBlock.height);
              ctx.setLineDash([]);
              
              ctx.fillStyle = previewBlock.type === 'aisle' ? '#374151' : '#FFFFFF';
              ctx.font = 'bold 14px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(
                `${previewBlock.label} (${Math.round(previewBlock.width/cellSize)}×${Math.round(previewBlock.height/cellSize)})`,
                previewX + previewBlock.width / 2,
                previewY + previewBlock.height / 2 + 4
              );
              
              ctx.globalAlpha = 1;
            }
          }, [blocks, selectedBlock, designMode, previewBlock, mode, viewOffset]);
          
          // 滑鼠事件處理
          const getCanvasCoordinates = (e) => {
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            return {
              x: e.clientX - rect.left,
              y: e.clientY - rect.top
            };
          };
          
          const getBlockAtPosition = (x, y) => {
            const worldX = x - viewOffset.x;
            const worldY = y - viewOffset.y;
            return blocks.find(block => 
              worldX >= block.x && worldX <= block.x + block.width &&
              worldY >= block.y && worldY <= block.y + block.height
            );
          };
          
          const getSeatAtPosition = (block, x, y) => {
            if (block.type !== 'seat' || !block.seats) return null;
            
            const seatWidth = block.width / block.seatsPerRow;
            const seatHeight = block.height / block.rows;
            const worldX = x - viewOffset.x;
            const worldY = y - viewOffset.y;
            const relativeX = worldX - block.x;
            const relativeY = worldY - block.y;
            
            const col = Math.floor(relativeX / seatWidth);
            const row = Math.floor(relativeY / seatHeight);
            
            if (col >= 0 && col < block.seatsPerRow && row >= 0 && row < block.rows) {
              const seatIndex = row * block.seatsPerRow + col;
              return { seat: block.seats[seatIndex], index: seatIndex };
            }
            return null;
          };
          
          // 計算所有區塊的邊界範圍
          const calculateBounds = () => {
            if (blocks.length === 0) return { minX: 0, minY: 0, maxX: 800, maxY: 600 };
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            blocks.forEach(block => {
              minX = Math.min(minX, block.x);
              minY = Math.min(minY, block.y);
              maxX = Math.max(maxX, block.x + block.width);
              maxY = Math.max(maxY, block.y + block.height);
            });
            
            const margin = cellSize * 2;
            return {
              minX: minX - margin,
              minY: minY - margin,
              maxX: maxX + margin,
              maxY: maxY + margin
            };
          };
          
          // 導出CSV檔案
          const exportToCSV = () => {
            try {
              let csvContent = '\ufeff';
              
              csvContent += '座位配置總覽\n';
              csvContent += '座位編號,區塊名稱,行數,列數,群體名稱,群體人數,狀態\n';
              
              blocks.filter(block => block.type === 'seat').forEach((block, blockIndex) => {
                if (block.seats) {
                  block.seats.forEach(seat => {
                    if (!seat.removed) {
                      const escapedName = seat.group ? `"${seat.group.name}"` : '未分配';
                      const groupSize = seat.group ? seat.group.size : '';
                      csvContent += `${seat.number},"座位區${blockIndex + 1}",${seat.row + 1},${seat.seat + 1},${escapedName},${groupSize},可用\n`;
                    }
                  });
                }
              });
              
              csvContent += '\n';
              
              csvContent += '群體分配統計\n';
              csvContent += '群體名稱,需求人數,已分配座位,未分配人數,分配率\n';
              
              groups.forEach(group => {
                const assignedCount = blocks
                  .filter(block => block.type === 'seat')
                  .reduce((sum, block) => 
                    sum + (block.seats ? block.seats.filter(seat => !seat.removed && seat.group?.id === group.id).length : 0), 0);
                
                const unassigned = Math.max(0, group.size - assignedCount);
                const assignmentRate = group.size > 0 ? `${Math.round((assignedCount / group.size) * 100)}%` : '0%';
                
                csvContent += `"${group.name}",${group.size},${assignedCount},${unassigned},${assignmentRate}\n`;
              });
              
              csvContent += '\n';
              
              csvContent += '統計摘要\n';
              csvContent += '項目,數值,說明\n';
              csvContent += `總座位數,${totalSeats},所有可用座位的總數\n`;
              csvContent += `已分配座位,${assignedSeats},已分配給群體的座位數\n`;
              csvContent += `未分配座位,${totalSeats - assignedSeats},尚未分配的座位數\n`;
              csvContent += `群體總數,${groups.length},報名群體的總數量\n`;
              csvContent += `需求人數,${totalNeeded},所有群體的人數總和\n`;
              csvContent += `分配完成率,${totalNeeded > 0 ? Math.round((assignedSeats / totalNeeded) * 100) : 0}%,已分配座位佔需求人數的比例\n`;
              csvContent += `座位利用率,${totalSeats > 0 ? Math.round((assignedSeats / totalSeats) * 100) : 0}%,已分配座位佔總座位的比例\n`;
              
              const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = url;
              link.download = `會場座位配置_${new Date().toISOString().slice(0, 10)}.csv`;
              link.style.display = 'none';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
              
              console.log('CSV檔案導出成功');
            } catch (error) {
              console.error('CSV導出失敗:', error);
              alert('CSV檔案導出失敗，請檢查瀏覽器控制台了解詳情');
            }
          };
          
          // 導出PNG圖片
          const exportToPNG = () => {
            try {
              const bounds = calculateBounds();
              const exportWidth = bounds.maxX - bounds.minX;
              const exportHeight = bounds.maxY - bounds.minY;
              
              const exportCanvas = document.createElement('canvas');
              exportCanvas.width = exportWidth;
              exportCanvas.height = exportHeight;
              const exportCtx = exportCanvas.getContext('2d');
              
              exportCtx.fillStyle = '#FFFFFF';
              exportCtx.fillRect(0, 0, exportWidth, exportHeight);
              
              exportCtx.strokeStyle = '#E5E7EB';
              exportCtx.lineWidth = 1;
              
              for (let x = 0; x <= exportWidth; x += cellSize) {
                exportCtx.beginPath();
                exportCtx.moveTo(x, 0);
                exportCtx.lineTo(x, exportHeight);
                exportCtx.stroke();
              }
              for (let y = 0; y <= exportHeight; y += cellSize) {
                exportCtx.beginPath();
                exportCtx.moveTo(0, y);
                exportCtx.lineTo(exportWidth, y);
                exportCtx.stroke();
              }
              
              blocks.forEach(block => {
                const blockX = block.x - bounds.minX;
                const blockY = block.y - bounds.minY;
                
                exportCtx.fillStyle = block.color;
                exportCtx.fillRect(blockX, blockY, block.width, block.height);
                
                exportCtx.strokeStyle = '#6B7280';
                exportCtx.lineWidth = 2;
                exportCtx.strokeRect(blockX, blockY, block.width, block.height);
                
                if (block.type !== 'seat') {
                  exportCtx.fillStyle = block.type === 'aisle' ? '#374151' : '#FFFFFF';
                  exportCtx.font = 'bold 16px Arial';
                  exportCtx.textAlign = 'center';
                  exportCtx.fillText(
                    block.label || toolStyles[block.type].label,
                    blockX + block.width / 2,
                    blockY + block.height / 2 + 6
                  );
                }
                
                if (block.type === 'seat' && block.seats) {
                  const seatWidth = block.width / block.seatsPerRow;
                  const seatHeight = block.height / block.rows;
                  
                  exportCtx.font = '12px Arial';
                  
                  block.seats.forEach((seat, index) => {
                    if (seat.removed) return;
                    
                    const row = Math.floor(index / block.seatsPerRow);
                    const col = index % block.seatsPerRow;
                    const seatX = blockX + col * seatWidth;
                    const seatY = blockY + row * seatHeight;
                    
                    exportCtx.fillStyle = seat.group ? seat.group.color : '#F3F4F6';
                    exportCtx.fillRect(seatX + 2, seatY + 2, seatWidth - 4, seatHeight - 4);
                    
                    exportCtx.strokeStyle = '#D1D5DB';
                    exportCtx.lineWidth = 1;
                    exportCtx.strokeRect(seatX + 2, seatY + 2, seatWidth - 4, seatHeight - 4);
                    
                    exportCtx.fillStyle = seat.group ? '#FFFFFF' : '#6B7280';
                    exportCtx.textAlign = 'center';
                    exportCtx.font = 'bold 11px Arial';
                    exportCtx.fillText(
                      seat.number.toString(),
                      seatX + seatWidth / 2,
                      seatY + seatHeight / 2 + 4
                    );
                  });
                }
              });
              
              const titleHeight = 60;
              const legendHeight = 100;
              const finalCanvas = document.createElement('canvas');
              finalCanvas.width = exportWidth;
              finalCanvas.height = exportHeight + titleHeight + legendHeight;
              const finalCtx = finalCanvas.getContext('2d');
              
              finalCtx.fillStyle = '#FFFFFF';
              finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
              
              finalCtx.fillStyle = '#1F2937';
              finalCtx.font = 'bold 24px Arial';
              finalCtx.textAlign = 'center';
              finalCtx.fillText('會場座位配置圖', finalCanvas.width / 2, 35);
              
              finalCtx.drawImage(exportCanvas, 0, titleHeight);
              
              const legendY = titleHeight + exportHeight + 20;
              finalCtx.fillStyle = '#374151';
              finalCtx.font = 'bold 16px Arial';
              finalCtx.textAlign = 'left';
              finalCtx.fillText('圖例：', 20, legendY);
              
              let legendX = 20;
              const legendItemHeight = 25;
              
              Object.entries(toolStyles).forEach(([tool, style], index) => {
                const itemY = legendY + 25 + Math.floor(index / 4) * legendItemHeight;
                const itemX = legendX + (index % 4) * 150;
                
                finalCtx.fillStyle = style.color;
                finalCtx.fillRect(itemX, itemY - 12, 16, 16);
                finalCtx.strokeStyle = '#6B7280';
                finalCtx.lineWidth = 1;
                finalCtx.strokeRect(itemX, itemY - 12, 16, 16);
                
                finalCtx.fillStyle = '#374151';
                finalCtx.font = '12px Arial';
                finalCtx.fillText(style.label, itemX + 20, itemY);
              });
              
              if (mode === 'assign' && groups.length > 0) {
                finalCtx.fillStyle = '#374151';
                finalCtx.font = 'bold 14px Arial';
                finalCtx.fillText('群體分配：', 20, legendY + 60);
                
                groups.forEach((group, index) => {
                  const itemY = legendY + 80 + Math.floor(index / 4) * legendItemHeight;
                  const itemX = 20 + (index % 4) * 150;
                  
                  finalCtx.fillStyle = group.color;
                  finalCtx.fillRect(itemX, itemY - 12, 16, 16);
                  finalCtx.strokeStyle = '#6B7280';
                  finalCtx.lineWidth = 1;
                  finalCtx.strokeRect(itemX, itemY - 12, 16, 16);
                  
                  finalCtx.fillStyle = '#374151';
                  finalCtx.font = '12px Arial';
                  finalCtx.fillText(`${group.name} (${group.size}人)`, itemX + 20, itemY);
                });
              }
              
              finalCanvas.toBlob((blob) => {
                if (blob) {
                  const url = URL.createObjectURL(blob);
                  const link = document.createElement('a');
                  link.href = url;
                  link.download = `會場座位圖_${new Date().toISOString().slice(0, 10)}.png`;
                  link.style.display = 'none';
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                  URL.revokeObjectURL(url);
                  console.log('PNG圖片導出成功');
                } else {
                  throw new Error('無法創建圖片blob');
                }
              }, 'image/png');
              
            } catch (error) {
              console.error('PNG導出失敗:', error);
              alert('PNG圖片導出失敗，請檢查瀏覽器控制台了解詳情');
            }
          };
          
          const handleMouseDown = (e) => {
            const coords = getCanvasCoordinates(e);
            
            if (mode === 'design') {
              if (designMode === 'pan') {
                setIsCanvasDragging(true);
                setCanvasDragStart(coords);
              } else {
                const clickedBlock = getBlockAtPosition(coords.x, coords.y);
                
                if (designMode === 'create') {
                  if (!clickedBlock) {
                    setIsDragging(true);
                    setDragStart(coords);
                    setSelectedBlock(null);
                    setPreviewBlock(null);
                  }
                } else if (designMode === 'move') {
                  if (clickedBlock) {
                    setDraggedBlock(clickedBlock);
                    setSelectedBlock(clickedBlock);
                    const worldX = coords.x - viewOffset.x;
                    const worldY = coords.y - viewOffset.y;
                    setDragOffset({
                      x: worldX - clickedBlock.x,
                      y: worldY - clickedBlock.y
                    });
                  }
                } else if (designMode === 'edit') {
                  if (clickedBlock && clickedBlock.type === 'seat') {
                    setSelectedBlock(clickedBlock);
                    const seatResult = getSeatAtPosition(clickedBlock, coords.x, coords.y);
                    if (seatResult && !seatResult.seat.removed) {
                      removeSeat(clickedBlock.id, seatResult.index);
                    }
                  } else {
                    setSelectedBlock(clickedBlock);
                  }
                }
              }
            }
          };
          
          const handleMouseMove = (e) => {
            const coords = getCanvasCoordinates(e);
            
            if (mode === 'design') {
              if (designMode === 'pan' && isCanvasDragging) {
                const deltaX = coords.x - canvasDragStart.x;
                const deltaY = coords.y - canvasDragStart.y;
                setViewOffset({
                  x: viewOffset.x + deltaX,
                  y: viewOffset.y + deltaY
                });
                setCanvasDragStart(coords);
              } else if (designMode === 'create' && isDragging) {
                const width = Math.abs(coords.x - dragStart.x);
                const height = Math.abs(coords.y - dragStart.y);
                const x = Math.min(coords.x, dragStart.x);
                const y = Math.min(coords.y, dragStart.y);
                
                const worldX = x - viewOffset.x;
                const worldY = y - viewOffset.y;
                
                const gridX = Math.round(worldX / cellSize) * cellSize;
                const gridY = Math.round(worldY / cellSize) * cellSize;
                const gridWidth = Math.round(width / cellSize) * cellSize;
                const gridHeight = Math.round(height / cellSize) * cellSize;
                
                if (gridWidth > 0 && gridHeight > 0) {
                  const preview = {
                    x: gridX,
                    y: gridY,
                    width: gridWidth,
                    height: gridHeight,
                    color: toolStyles[currentTool].color,
                    label: toolStyles[currentTool].label,
                    type: currentTool
                  };
                  
                  if (currentTool === 'seat') {
                    const minSeatSize = 25;
                    const maxSeatsPerRow = Math.floor(gridWidth / minSeatSize);
                    const maxRows = Math.floor(gridHeight / minSeatSize);
                    const seatsPerRow = Math.max(1, maxSeatsPerRow);
                    const rows = Math.max(1, maxRows);
                    const totalSeats = rows * seatsPerRow;
                    
                    preview.label = `座位區 (${rows}行×${seatsPerRow}位=${totalSeats}座位)`;
                  }
                  
                  setPreviewBlock(preview);
                }
              } else if (designMode === 'move' && draggedBlock) {
                const worldX = coords.x - viewOffset.x;
                const worldY = coords.y - viewOffset.y;
                const newX = Math.round((worldX - dragOffset.x) / cellSize) * cellSize;
                const newY = Math.round((worldY - dragOffset.y) / cellSize) * cellSize;
                
                setBlocks(blocks.map(block => 
                  block.id === draggedBlock.id 
                    ? { ...block, x: newX, y: newY }
                    : block
                ));
              } else {
                setPreviewBlock(null);
              }
            } else {
              setPreviewBlock(null);
            }
          };
          
          const handleMouseUp = (e) => {
            const coords = getCanvasCoordinates(e);
            
            if (mode === 'design') {
              if (designMode === 'pan' && isCanvasDragging) {
                setIsCanvasDragging(false);
              } else if (designMode === 'create' && isDragging) {
                const width = Math.abs(coords.x - dragStart.x);
                const height = Math.abs(coords.y - dragStart.y);
                const x = Math.min(coords.x, dragStart.x);
                const y = Math.min(coords.y, dragStart.y);
                
                if (width > 20 && height > 20) {
                  const worldX = x - viewOffset.x;
                  const worldY = y - viewOffset.y;
                  const gridWidth = Math.round(width / cellSize) * cellSize;
                  const gridHeight = Math.round(height / cellSize) * cellSize;
                  
                  const newBlock = {
                    id: Date.now().toString(),
                    type: currentTool,
                    x: Math.round(worldX / cellSize) * cellSize,
                    y: Math.round(worldY / cellSize) * cellSize,
                    width: gridWidth,
                    height: gridHeight,
                    color: toolStyles[currentTool].color,
                    label: toolStyles[currentTool].label
                  };
                  
                  if (currentTool === 'seat') {
                    const minSeatSize = 25;
                    const maxSeatsPerRow = Math.floor(gridWidth / minSeatSize);
                    const maxRows = Math.floor(gridHeight / minSeatSize);
                    
                    const seatsPerRow = Math.max(1, maxSeatsPerRow);
                    const rows = Math.max(1, maxRows);
                    
                    newBlock.rows = rows;
                    newBlock.seatsPerRow = seatsPerRow;
                    newBlock.seats = generateSeats(rows, seatsPerRow);
                  }
                  
                  const updatedBlocks = [...blocks, newBlock];
                  
                  if (currentTool === 'aisle') {
                    handleAisleConflicts(newBlock, updatedBlocks);
                  } else {
                    setBlocks(updatedBlocks);
                    if (currentTool === 'seat') {
                      setTimeout(() => {
                        setBlocks(prevBlocks => {
                          const reassigned = reassignSeatNumbers(prevBlocks);
                          return reassigned;
                        });
                      }, 10);
                    }
                  }
                  
                  setSelectedBlock(newBlock);
                }
                
                setPreviewBlock(null);
              } else if (designMode === 'move' && draggedBlock) {
                if (draggedBlock.type === 'aisle') {
                  handleAisleConflicts(draggedBlock, blocks);
                } else if (draggedBlock.type === 'seat') {
                  setTimeout(() => {
                    setBlocks(prevBlocks => reassignSeatNumbers(prevBlocks));
                  }, 10);
                }
                setDraggedBlock(null);
              }
            }
            setIsDragging(false);
          };
          
          // 處理走道與座位區的衝突
          const handleAisleConflicts = (aisleBlock, blockList) => {
            const updatedBlocks = blockList.map(block => {
              if (block.type === 'seat' && block.seats) {
                const updatedSeats = block.seats.map(seat => {
                  if (seat.removed) return seat;
                  
                  const seatWidth = block.width / block.seatsPerRow;
                  const seatHeight = block.height / block.rows;
                  const seatIndex = block.seats.indexOf(seat);
                  const row = Math.floor(seatIndex / block.seatsPerRow);
                  const col = seatIndex % block.seatsPerRow;
                  const seatX = block.x + col * seatWidth;
                  const seatY = block.y + row * seatHeight;
                  
                  const isOverlapping = !(
                    seatX + seatWidth <= aisleBlock.x ||
                    seatX >= aisleBlock.x + aisleBlock.width ||
                    seatY + seatHeight <= aisleBlock.y ||
                    seatY >= aisleBlock.y + aisleBlock.height
                  );
                  
                  if (isOverlapping) {
                    return { ...seat, removed: true };
                  }
                  return seat;
                });
                
                return { ...block, seats: updatedSeats };
              }
              return block;
            });
            
            setBlocks(updatedBlocks);
            setTimeout(() => {
              setBlocks(prevBlocks => reassignSeatNumbers(prevBlocks));
            }, 10);
          };
          
          // 移除單個座位
          const removeSeat = (blockId, seatIndex) => {
            const updatedBlocks = blocks.map(block => {
              if (block.id === blockId && block.seats) {
                const updatedSeats = [...block.seats];
                updatedSeats[seatIndex] = { ...updatedSeats[seatIndex], removed: true };
                return { ...block, seats: updatedSeats };
              }
              return block;
            });
            
            setBlocks(updatedBlocks);
            setTimeout(() => {
              setBlocks(prevBlocks => reassignSeatNumbers(prevBlocks));
            }, 10);
          };
          
          // 恢復選中區塊的所有座位
          const restoreAllSeats = () => {
            if (selectedBlock && selectedBlock.type === 'seat') {
              const updatedBlocks = blocks.map(block => {
                if (block.id === selectedBlock.id && block.seats) {
                  const updatedSeats = block.seats.map(seat => ({ ...seat, removed: false }));
                  return { ...block, seats: updatedSeats };
                }
                return block;
              });
              
              setBlocks(updatedBlocks);
              setTimeout(() => {
                setBlocks(prevBlocks => reassignSeatNumbers(prevBlocks));
              }, 10);
            }
          };
          
          // 刪除選中的區塊
          const deleteSelectedBlock = () => {
            if (selectedBlock) {
              const updatedBlocks = blocks.filter(block => block.id !== selectedBlock.id);
              
              setBlocks(updatedBlocks);
              
              if (selectedBlock.type === 'seat') {
                setTimeout(() => {
                  setBlocks(prevBlocks => reassignSeatNumbers(prevBlocks));
                }, 10);
              }
              
              setSelectedBlock(null);
            }
          };
          
          // 自動分配座位
          const autoAssignSeats = () => {
            const seatBlocks = blocks.filter(block => block.type === 'seat');
            const updatedBlocks = [...blocks];
            
            let groupIndex = 0;
            let seatIndex = 0;
            
            seatBlocks.forEach(block => {
              if (block.seats) {
                block.seats.forEach(seat => {
                  if (!seat.removed) {
                    seat.group = null;
                  }
                });
              }
            });
            
            groups.forEach(group => {
              let assigned = 0;
              
              while (assigned < group.size && groupIndex < seatBlocks.length) {
                const currentBlock = seatBlocks[groupIndex];
                const availableSeats = currentBlock.seats.filter(seat => !seat.removed);
                
                while (assigned < group.size && seatIndex < availableSeats.length) {
                  availableSeats[seatIndex].group = group;
                  assigned++;
                  seatIndex++;
                }
                
                if (seatIndex >= availableSeats.length) {
                  groupIndex++;
                  seatIndex = 0;
                }
              }
            });
            
            setBlocks(updatedBlocks);
          };
          
          // 清空座位分配
          const clearAssignments = () => {
            const updatedBlocks = blocks.map(block => {
              if (block.type === 'seat' && block.seats) {
                return {
                  ...block,
                  seats: block.seats.map(seat => ({ ...seat, group: null }))
                };
              }
              return block;
            });
            setBlocks(updatedBlocks);
          };
          
          // 計算統計數據
          const totalSeats = blocks
            .filter(block => block.type === 'seat')
            .reduce((sum, block) => sum + (block.seats ? block.seats.filter(seat => !seat.removed).length : 0), 0);
          
          const assignedSeats = blocks
            .filter(block => block.type === 'seat')
            .reduce((sum, block) => 
              sum + (block.seats ? block.seats.filter(seat => !seat.removed && seat.group).length : 0), 0);
          
          const totalNeeded = groups.reduce((sum, group) => sum + group.size, 0);
          
          // 新增群體
          const addGroup = () => {
            if (newGroup.name && newGroup.size > 0) {
              const group = {
                id: Date.now(),
                name: newGroup.name,
                size: parseInt(newGroup.size),
                color: generateColor()
              };
              setGroups([...groups, group]);
              setNewGroup({ name: '', size: 0 });
              setShowGroupModal(false);
            }
          };
          
          const generateColor = () => {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];
            return colors[Math.floor(Math.random() * colors.length)];
          };
          
          const removeGroup = (groupId) => {
            setGroups(groups.filter(g => g.id !== groupId));
            clearAssignments();
          };
          
          return React.createElement('div', { className: "min-h-screen bg-gray-50 p-4" },
            React.createElement('div', { className: "max-w-7xl mx-auto" },
              // 標題
              React.createElement('div', { className: "bg-white rounded-lg shadow-md p-6 mb-6" },
                React.createElement('h1', { className: "text-2xl font-bold text-gray-800 mb-2 flex items-center" },
                  React.createElement(Users, { className: "mr-3 text-blue-600" }),
                  "會場座位設計系統"
                ),
                React.createElement('p', { className: "text-gray-600" }, "拖拉設計會場佈局，智慧分配座位，支援缺角座位設計")
              ),
              
              // 模式切換
              React.createElement('div', { className: "bg-white rounded-lg shadow-md p-4 mb-6" },
                React.createElement('div', { className: "flex space-x-4" },
                  React.createElement('button', {
                    onClick: () => setMode('design'),
                    className: `px-4 py-2 rounded-md flex items-center ${mode === 'design' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`
                  },
                    React.createElement(Edit3, { className: "w-4 h-4 mr-2" }),
                    "設計模式"
                  ),
                  React.createElement('button', {
                    onClick: () => setMode('assign'),
                    className: `px-4 py-2 rounded-md flex items-center ${mode === 'assign' ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-700'}`
                  },
                    React.createElement(Users, { className: "w-4 h-4 mr-2" }),
                    "分配模式"
                  )
                ),
                
                // 設計子模式
                mode === 'design' && React.createElement('div', { className: "flex space-x-2 mt-4 pt-4 border-t" },
                  React.createElement('button', {
                    onClick: () => setDesignMode('create'),
                    className: `px-3 py-2 rounded-md flex items-center text-sm ${designMode === 'create' ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-700'}`
                  },
                    React.createElement(Plus, { className: "w-4 h-4 mr-1" }),
                    "創建區塊"
                  ),
                  React.createElement('button', {
                    onClick: () => setDesignMode('move'),
                    className: `px-3 py-2 rounded-md flex items-center text-sm ${designMode === 'move' ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-700'}`
                  },
                    React.createElement(Hand, { className: "w-4 h-4 mr-1" }),
                    "移動區塊"
                  ),
                  React.createElement('button', {
                    onClick: () => setDesignMode('edit'),
                    className: `px-3 py-2 rounded-md flex items-center text-sm ${designMode === 'edit' ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-700'}`
                  },
                    React.createElement(Edit3, { className: "w-4 h-4 mr-1" }),
                    "編輯座位"
                  ),
                  React.createElement('button', {
                    onClick: () => setDesignMode('pan'),
                    className: `px-3 py-2 rounded-md flex items-center text-sm ${designMode === 'pan' ? 'bg-purple-600 text-white' : 'bg-gray-100 text-gray-700'}`
                  },
                    React.createElement(Move, { className: "w-4 h-4 mr-1" }),
                    "移動畫布"
                  )
                )
              ),
              
              React.createElement('div', { className: "grid grid-cols-1 lg:grid-cols-4 gap-6" },
                // 左側工具面板
                React.createElement('div', { className: "space-y-6" },
                  // 設計工具
                  mode === 'design' && React.createElement('div', { className: "bg-white rounded-lg shadow-md p-4" },
                    React.createElement('h3', { className: "font-semibold mb-3" }, "設計工具"),
                    
                    designMode === 'create' && React.createElement('div', { className: "space-y-2" },
                      Object.entries(toolStyles).map(([tool, style]) =>
                        React.createElement('button', {
                          key: tool,
                          onClick: () => setCurrentTool(tool),
                          className: `w-full p-3 rounded-md border-2 flex items-center ${currentTool === tool ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-gray-300'}`
                        },
                          React.createElement('div', { 
                            className: "w-4 h-4 rounded mr-3",
                            style: { backgroundColor: style.color }
                          }),
                          style.label
                        )
                      ),
                      
                      currentTool === 'seat' && React.createElement('div', { className: "mt-4 pt-4 border-t" },
                        React.createElement('p', { className: "text-xs text-gray-500" },
                          "座位數量完全根據拖拉區域大小決定，座位編號會自動連續排列"
                        )
                      )
                    ),
                    
                    designMode === 'move' && React.createElement('p', { className: "text-sm text-gray-600" }, "點擊並拖動區塊來移動位置"),
                    
                    designMode === 'edit' && React.createElement('div', null,
                      React.createElement('p', { className: "text-sm text-gray-600 mb-3" }, "點擊座位區塊，然後點擊個別座位來移除"),
                      selectedBlock && selectedBlock.type === 'seat' && React.createElement('button', {
                        onClick: restoreAllSeats,
                        className: "w-full bg-green-600 text-white p-2 rounded-md hover:bg-green-700"
                      }, "恢復所有座位")
                    ),
                    
                    designMode === 'pan' && React.createElement('div', null,
                      React.createElement('p', { className: "text-sm text-gray-600 mb-3" }, "拖拉畫布來移動視野，探索整個會場空間"),
                      React.createElement('div', { className: "bg-blue-50 border border-blue-200 rounded-md p-3" },
                        React.createElement('h4', { className: "text-sm font-medium text-blue-800 mb-2" }, "畫布位置"),
                        React.createElement('div', { className: "text-xs text-blue-600" },
                          React.createElement('div', null, "X偏移: " + Math.round(viewOffset.x) + "px"),
                          React.createElement('div', null, "Y偏移: " + Math.round(viewOffset.y) + "px")
                        ),
                        React.createElement('button', {
                          onClick: () => setViewOffset({ x: 0, y: 0 }),
                          className: "mt-2 w-full bg-blue-600 text-white text-xs py-1 px-2 rounded hover:bg-blue-700"
                        }, "重置視野")
                      )
                    ),
                    
                    selectedBlock && React.createElement('div', { className: "mt-4 pt-4 border-t" },
                      React.createElement('p', { className: "text-sm text-gray-600 mb-2" }, "選中區塊"),
                      React.createElement('p', { className: "font-medium" }, selectedBlock.label),
                      React.createElement('button', {
                        onClick: deleteSelectedBlock,
                        className: "w-full mt-2 bg-red-600 text-white p-2 rounded-md hover:bg-red-700"
                      }, "刪除區塊")
                    )
                  ),
                  
                  // 群體管理
                  mode === 'assign' && React.createElement('div', { className: "bg-white rounded-lg shadow-md p-4" },
                    React.createElement('div', { className: "flex justify-between items-center mb-3" },
                      React.createElement('h3', { className: "font-semibold" }, "報名群體"),
                      React.createElement('button', {
                        onClick: () => setShowGroupModal(true),
                        className: "bg-green-600 text-white px-3 py-1 rounded-md hover:bg-green-700 flex items-center text-sm"
                      },
                        React.createElement(Plus, { className: "w-3 h-3 mr-1" }),
                        "新增"
                      )
                    ),
                    
                    React.createElement('div', { className: "space-y-2" },
                      groups.map(group =>
                        React.createElement('div', { key: group.id, className: "border rounded-lg p-2", style: {borderColor: group.color} },
                          React.createElement('div', { className: "flex items-center justify-between" },
                            React.createElement('div', { className: "flex items-center" },
                              React.createElement('div', { 
                                className: "w-3 h-3 rounded-full mr-2",
                                style: {backgroundColor: group.color}
                              }),
                              React.createElement('div', null,
                                React.createElement('div', { className: "font-medium text-sm" }, group.name),
                                React.createElement('div', { className: "text-xs text-gray-600" }, group.size + " 人")
                              )
                            ),
                            React.createElement('button', {
                              onClick: () => removeGroup(group.id),
                              className: "text-red-500 hover:text-red-700 text-sm"
                            }, "✕")
                          )
                        )
                      )
                    )
                  ),
                  
                  // 統計資訊
                  React.createElement('div', { className: "bg-white rounded-lg shadow-md p-4" },
                    React.createElement('h3', { className: "font-semibold mb-3" }, "統計資訊"),
                    React.createElement('div', { className: "space-y-2 text-sm" },
                      React.createElement('div', { className: "flex justify-between" },
                        React.createElement('span', null, "可用座位："),
                        React.createElement('span', { className: "font-medium" }, totalSeats)
                      ),
                      mode === 'assign' && [
                        React.createElement('div', { className: "flex justify-between", key: "needed" },
                          React.createElement('span', null, "需求人數："),
                          React.createElement('span', { className: "font-medium" }, totalNeeded)
                        ),
                        React.createElement('div', { className: "flex justify-between", key: "assigned" },
                          React.createElement('span', null, "已分配："),
                          React.createElement('span', { className: "font-medium text-green-600" }, assignedSeats)
                        ),
                        React.createElement('div', { className: "flex justify-between", key: "remaining" },
                          React.createElement('span', null, "剩餘座位："),
                          React.createElement('span', { className: "font-medium" }, totalSeats - assignedSeats)
                        )
                      ]
                    )
                  ),
                  
                  // 導出功能
                  React.createElement('div', { className: "bg-white rounded-lg shadow-md p-4" },
                    React.createElement('h3', { className: "font-semibold mb-3" }, "導出功能"),
                    React.createElement('div', { className: "space-y-2" },
                      React.createElement('button', {
                        onClick: exportToPNG,
                        className: "w-full bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 flex items-center justify-center",
                        disabled: blocks.length === 0
                      },
                        React.createElement(Save, { className: "w-4 h-4 mr-2" }),
                        "導出PNG圖片"
                      ),
                      React.createElement('button', {
                        onClick: exportToCSV,
                        className: "w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 flex items-center justify-center",
                        disabled: blocks.length === 0
                      },
                        React.createElement(Download, { className: "w-4 h-4 mr-2" }),
                        "導出CSV檔案"
                      )
                    ),
                    React.createElement('div', { className: "text-xs text-gray-500 mt-2 space-y-1" },
                      React.createElement('p', null, "• PNG：完整會場佈局圖片，包含標題和圖例"),
                      React.createElement('p', null, "• CSV：詳細座位配置數據，包含統計分析")
                    )
                  ),
                  
                  // 操作按鈕
                  mode === 'assign' && React.createElement('div', { className: "bg-white rounded-lg shadow-md p-4" },
                    React.createElement('h3', { className: "font-semibold mb-3" }, "操作"),
                    React.createElement('div', { className: "space-y-2" },
                      React.createElement('button', {
                        onClick: autoAssignSeats,
                        className: "w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 flex items-center justify-center"
                      },
                        React.createElement(Shuffle, { className: "w-4 h-4 mr-2" }),
                        "自動分配"
                      ),
                      React.createElement('button', {
                        onClick: clearAssignments,
                        className: "w-full bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 flex items-center justify-center"
                      },
                        React.createElement(RotateCcw, { className: "w-4 h-4 mr-2" }),
                        "清空分配"
                      )
                    )
                  )
                ),
                
                // 主畫布區域
                React.createElement('div', { className: "lg:col-span-3" },
                  React.createElement('div', { className: "bg-white rounded-lg shadow-md p-4" },
                    React.createElement('h3', { className: "font-semibold mb-4" }, "會場佈局設計"),
                    
                    mode === 'design' && React.createElement('div', { className: "text-sm text-gray-600 mb-4" },
                      designMode === 'create' && "選擇工具後，在畫布上拖拉滑鼠來創建區塊。座位區塊的數量會根據拖拉範圍自動調整",
                      designMode === 'move' && "點擊並拖動區塊來移動位置，走道會自動處理座位衝突",
                      designMode === 'edit' && "點擊座位區塊選中，然後點擊個別座位來移除（紅框表示可編輯）",
                      designMode === 'pan' && "拖拉畫布來移動視野，設計超大型會場佈局"
                    ),
                    
                    React.createElement('div', { className: "border-2 border-gray-300 rounded-lg overflow-hidden" },
                      React.createElement('canvas', {
                        ref: canvasRef,
                        width: canvasWidth,
                        height: canvasHeight,
                        onMouseDown: handleMouseDown,
                        onMouseMove: handleMouseMove,
                        onMouseUp: handleMouseUp,
                        className: 
                          designMode === 'create' ? 'cursor-crosshair' : 
                          designMode === 'move' ? 'cursor-move' : 
                          designMode === 'pan' ? (isCanvasDragging ? 'cursor-grabbing' : 'cursor-grab') :
                          'cursor-pointer'
                      })
                    ),
                    
                    // 圖例
                    React.createElement('div', { className: "mt-4 pt-4 border-t" },
                      React.createElement('h4', { className: "font-medium mb-3" }, "圖例"),
                      React.createElement('div', { className: "grid grid-cols-2 md:grid-cols-4 gap-4" },
                        Object.entries(toolStyles).map(([tool, style]) =>
                          React.createElement('div', { key: tool, className: "flex items-center" },
                            React.createElement('div', { 
                              className: "w-4 h-4 rounded mr-2",
                              style: {backgroundColor: style.color}
                            }),
                            React.createElement('span', { className: "text-sm" }, style.label)
                          )
                        ).concat(
                          mode === 'assign' ? groups.map(group =>
                            React.createElement('div', { key: group.id, className: "flex items-center" },
                              React.createElement('div', { 
                                className: "w-4 h-4 rounded mr-2",
                                style: {backgroundColor: group.color}
                              }),
                              React.createElement('span', { className: "text-sm" }, group.name)
                            )
                          ) : []
                        )
                      )
                    )
                  )
                )
              ),
              
              // 新增群體模態框
              showGroupModal && React.createElement('div', { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" },
                React.createElement('div', { className: "bg-white rounded-lg p-6 w-96" },
                  React.createElement('h3', { className: "text-lg font-semibold mb-4" }, "新增報名群體"),
                  React.createElement('div', { className: "space-y-4" },
                    React.createElement('div', null,
                      React.createElement('label', { className: "block text-sm font-medium mb-1" }, "群體名稱"),
                      React.createElement('input', {
                        type: "text",
                        value: newGroup.name,
                        onChange: (e) => setNewGroup({...newGroup, name: e.target.value}),
                        className: "w-full p-2 border rounded-md",
                        placeholder: "例如：企業A團隊"
                      })
                    ),
                    React.createElement('div', null,
                      React.createElement('label', { className: "block text-sm font-medium mb-1" }, "人數"),
                      React.createElement('input', {
                        type: "number",
                        value: newGroup.size,
                        onChange: (e) => setNewGroup({...newGroup, size: e.target.value}),
                        className: "w-full p-2 border rounded-md",
                        placeholder: "請輸入人數",
                        min: "1"
                      })
                    ),
                    React.createElement('div', { className: "flex space-x-3 pt-4" },
                      React.createElement('button', {
                        onClick: addGroup,
                        className: "flex-1 bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700"
                      }, "新增"),
                      React.createElement('button', {
                        onClick: () => setShowGroupModal(false),
                        className: "flex-1 bg-gray-300 text-gray-700 py-2 rounded-md hover:bg-gray-400"
                      }, "取消")
                    )
                  )
                )
              )
            )
          );
        };

        // 等待所有資源載入完成再渲染
        function initApp() {
          try {
            const root = ReactDOM.createRoot ? ReactDOM.createRoot(document.getElementById('root')) : null;
            if (root) {
              root.render(React.createElement(SeatingDesigner));
            } else {
              ReactDOM.render(React.createElement(SeatingDesigner), document.getElementById('root'));
            }
            console.log('會場座位設計系統載入成功！');
          } catch (error) {
            console.error('應用載入失敗:', error);
            document.getElementById('root').innerHTML = `
              <div style="padding: 40px; text-align: center; color: #dc2626;">
                <h2 style="margin-bottom: 16px;">系統載入失敗</h2>
                <p style="margin-bottom: 16px;">請檢查瀏覽器控制台查看詳細錯誤信息</p>
                <p style="font-size: 14px; color: #6b7280;">錯誤: ${error.message}</p>
                <button onclick="location.reload()" style="margin-top: 16px; padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">重新載入</button>
              </div>
            `;
          }
        }

        // 確保所有依賴都載入完成
        if (typeof React !== 'undefined' && typeof ReactDOM !== 'undefined') {
          initApp();
        } else {
          window.addEventListener('load', initApp);
        }
    </script>
</body>
</html>